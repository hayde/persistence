/*
 * (C) 2014 hayde.eu
 */
package eu.hayde.box.persistence;

import eu.hayde.box.persistence.annotation.Basic;
import eu.hayde.box.persistence.annotation.Column;
import eu.hayde.box.persistence.annotation.GeneratedValue;
import eu.hayde.box.persistence.annotation.GenerationType;
import eu.hayde.box.persistence.annotation.Id;
import eu.hayde.box.persistence.annotation.JoinColumn;
import eu.hayde.box.persistence.annotation.Lob;
import eu.hayde.box.persistence.annotation.ManyToOne;
import eu.hayde.box.persistence.execptions.HaydePersistenceException;
import java.lang.reflect.Field;
import java.text.SimpleDateFormat;

/**
 *
 * @author cansenturk
 * @version 2012/06/29
 */
public class ColumnDefinition {

    //<editor-fold defaultstate="collapsed" desc="Exceptions">
    public static class ColumnAnnotationForFieldException extends HaydePersistenceException {

        public ColumnAnnotationForFieldException(String string) {
            super(string);
        }
    }

    public static class ColumnAnnotationRequireDatabaseFieldNameException extends HaydePersistenceException {

        public ColumnAnnotationRequireDatabaseFieldNameException(String string) {
            super(string);
        }
    }

    public static class VariableTypeHasNoMatchingSQLTypeException extends HaydePersistenceException {

        public VariableTypeHasNoMatchingSQLTypeException(String string) {
            super(string);
        }
    }
    //</editor-fold>
    private boolean key = false;
    private String javaName;
    private String dbName;				//	(Optional) The db name of the column.
    private String sqlDefinition;
    private int length;				//	(Optional) The column length.
    private boolean unique;				//	(Optional) Whether the property is a unique key.
    private boolean updatable;			//	(Optional) Whether the column is included in SQL UPDATE statements generated by the persistence provider.
    private boolean insertable;			//	(Optional) Whether the column is included in SQL INSERT statements generated by the persistence provider.
    private boolean nullable;			//	(Optional) Whether the database column is nullable.
    private int precision;			//	(Optional) The precision for a decimal (exact numeric) column.
    private int scale;				//	(Optional) The scale for a decimal (exact numeric) column.
    private boolean lob;
    ;				//  (Optional) if the field is a lob
	private GenerationType generationType = null;	// (optional) which generation type
    private Class valueType;
    private Object value;				// the value, only necessary while creating statements.

    public ColumnDefinition(ColumnDefinition copy) {
        this.key = copy.key;
        this.javaName = copy.javaName;
        this.dbName = copy.dbName;				//	(Optional) The db name of the column.
        this.sqlDefinition = copy.sqlDefinition;
        this.length = copy.length;				//	(Optional) The column length.
        this.unique = copy.unique;				//	(Optional) Whether the property is a unique key.
        this.updatable = copy.updatable;			//	(Optional) Whether the column is included in SQL UPDATE statements generated by the persistence provider.
        this.insertable = copy.insertable;			//	(Optional) Whether the column is included in SQL INSERT statements generated by the persistence provider.
        this.nullable = copy.nullable;			//	(Optional) Whether the database column is nullable.
        this.precision = copy.precision;			//	(Optional) The precision for a decimal (exact numeric) column.
        this.scale = copy.scale;				//	(Optional) The scale for a decimal (exact numeric) column.
        this.lob = copy.lob;

        this.generationType = copy.generationType;
        this.valueType = copy.valueType;
        this.value = copy.value;
    }

    public ColumnDefinition(Field parField) throws ColumnAnnotationForFieldException, ColumnAnnotationRequireDatabaseFieldNameException, VariableTypeHasNoMatchingSQLTypeException {

        // check if there is a annotation for column
        if (!parField.isAnnotationPresent(Column.class)
                && !parField.isAnnotationPresent(JoinColumn.class)) {
            throw new ColumnAnnotationForFieldException("This field is missing the @Column annotation: " + parField.getName());
        }

        javaName = parField.getName();
        valueType = parField.getType();

        _loadFieldAnnotations(parField);

    }

    private void _loadFieldAnnotations(Field parField) throws ColumnAnnotationRequireDatabaseFieldNameException, VariableTypeHasNoMatchingSQLTypeException {

        for (int i = 0; i < 10; i++) {
            switch (i) {
                case 0:
                    if (parField.isAnnotationPresent(Column.class)) {
                        // get the Column infos
                        Column annotationColumn = (Column) parField.getAnnotation(Column.class);
                        sqlDefinition = annotationColumn.columnDefinition();
                        insertable = annotationColumn.insertable();
                        length = annotationColumn.length();
                        dbName = annotationColumn.name();
                        nullable = annotationColumn.nullable();
                        precision = annotationColumn.precision();
                        scale = annotationColumn.scale();
                        //annotationColumn.table();
                        unique = annotationColumn.unique();
                        updatable = annotationColumn.updatable();

                        // now, if the field doesn't have the db name set, ...
                        if (dbName == null) {
                            throw new ColumnAnnotationRequireDatabaseFieldNameException("the variable " + javaName + " requires a entry for the dending database field like @Column( name='DBNAME_HERE' ).");
                        }
                    }
                    break;

                case 1:
                    if (parField.isAnnotationPresent(Id.class)) {
                        this.key = true;
                    } else {
                        this.key = false;
                    }
                    break;

                case 2:
                    if (parField.isAnnotationPresent(GeneratedValue.class)) {
                        GeneratedValue gValue = parField.getAnnotation(GeneratedValue.class);
                        generationType = gValue.strategy();
                    }
                    break;

                case 3:
                    if (parField.isAnnotationPresent(Lob.class)) {
                        lob = true;
                    } else {
                        lob = false;
                    }
                    break;
                case 4:
                    if (parField.isAnnotationPresent(JoinColumn.class)) {
                        JoinColumn annotationJoinColumn = (JoinColumn) parField.getAnnotation(JoinColumn.class);
                        sqlDefinition = annotationJoinColumn.columnDefinition();
                        insertable = annotationJoinColumn.insertable();
                        dbName = annotationJoinColumn.name();
                        nullable = annotationJoinColumn.nullable();
                        //annotationColumn.table();
                        unique = annotationJoinColumn.unique();
                        updatable = annotationJoinColumn.updatable();
                        dbName = annotationJoinColumn.name();

                        // now, if the field doesn't have the db name set, ...
                        if (dbName == null) {
                            throw new ColumnAnnotationRequireDatabaseFieldNameException("the variable " + javaName + " requires a entry for the dending database field like @JoinColumn( name='DBNAME_HERE' ).");
                        }
                    }
                    break;
                case 5:
                    if (parField.isAnnotationPresent(ManyToOne.class)) {
                        // we will do nohting here
                    }
                    break;
                case 6:
                    if (parField.isAnnotationPresent(Basic.class)) {
                        // do nothing here
                    }
                    break;

                case 9: // some cleaning stuff!
                {
                    if (sqlDefinition == null || sqlDefinition.isEmpty()) {
                        sqlDefinition = this._getSQLType();
                    }
                }
                break;

            }
        }
    }

    private String _getSQLType() throws VariableTypeHasNoMatchingSQLTypeException {
        String returnValue = null;

        if (valueType == null) {
            returnValue = null;
        } else if (valueType.equals(java.lang.Long.class)) {
            returnValue = "BIGINT";
        } else if (valueType.equals(java.lang.String.class)) {
            returnValue = "VARCHAR(" + length + ")";
        } else if (valueType.equals(java.lang.Float.class)) {
            returnValue = "REAL";
        } else if (valueType.equals(java.lang.Integer.class)) {
            returnValue = "INTEGER";
        } else if (valueType.equals(java.lang.Boolean.class)) {
            returnValue = "BIT";
        } else if (valueType.equals(java.util.Date.class)) {
            returnValue = "DATETIME";
        } else if (valueType.equals(java.sql.Date.class)) {
            returnValue = "DATE";
        } else if (valueType.equals(java.sql.Timestamp.class)) {
            returnValue = "TIMESTAMP";
        } else if (valueType.equals(java.sql.Time.class)) {
            returnValue = "TIME";
        } else if (valueType.equals(java.sql.Blob.class)) {
            returnValue = "BLOB";
        } else if (valueType.equals(java.lang.Double.class)) {
            returnValue = "DOUBLE";
        } else if (valueType.equals(java.math.BigDecimal.class)) {
            return "DECIMAL(" + precision + "," + scale + ")";
        } else if (valueType.equals(Byte.class)) {
            return "TINYINT";
        } else if (valueType.equals(byte[].class)) {
            return "VARBINARY";
        }

        // there was no matching sql type in here!
        if (returnValue == null) {
            throw new VariableTypeHasNoMatchingSQLTypeException("the variable " + javaName + " of type: " + valueType.getCanonicalName() + " has no matching SQL type declaration. Change it or declare it manually with @Column(columnDefinition='SQLTYPENAME')");
        }

        return returnValue;
    }

    /**
     * if we cast the value to a specific type, the types are different then the
     * declaration type.
     *
     * therefor we need a special function to match the casting to the
     * definition and visa versa
     *
     * @return
     */
    public String getCastType() {
        String returnValue = sqlDefinition;

        if (sqlDefinition.equalsIgnoreCase("BIGINT")
                || sqlDefinition.equalsIgnoreCase("INTEGER")
                || sqlDefinition.equalsIgnoreCase("TINYINT")
                || sqlDefinition.equalsIgnoreCase("BIT")) {
            returnValue = "SIGNED";
        } else if (sqlDefinition.equalsIgnoreCase("VARCHAR")
                || sqlDefinition.equalsIgnoreCase("BLOB")
                || sqlDefinition.equalsIgnoreCase("STRING")) {
            returnValue = "CHAR";
        } else if (sqlDefinition.equalsIgnoreCase("BINARY")
                || sqlDefinition.equalsIgnoreCase("VARBINARY")) {
            returnValue = "BINARY";
        } else if (sqlDefinition.equalsIgnoreCase("DATE")) {
            returnValue = "DATE";
        } else if (sqlDefinition.equalsIgnoreCase("DATETIME")
                || sqlDefinition.equalsIgnoreCase("TIMESTAMP")) {
            returnValue = "DATETIME";
        } else if (sqlDefinition.equalsIgnoreCase("TIME")) {
            returnValue = "TIME";
        } else if (sqlDefinition.equalsIgnoreCase("REAL")
                || sqlDefinition.equalsIgnoreCase("DOUBLE")
                || sqlDefinition.startsWith("DECIMAL")) {
            returnValue = "DECIMAL";
        }

        return returnValue;
    }

    public String quotedValue() {

        String returnValue = "null";

        if (value == null) {
            return returnValue;
        }

        if (valueType.equals(java.lang.Long.class)) {
            returnValue = ((Long) value).toString();

        } else if (valueType.equals(java.lang.String.class)) {
            // cut to the correct length

            if (value == null) {
                returnValue = "NULL";
            } else {

                // clean up some stuff:
                // 1. length: cut the original!!!
                if (value != null && this.length > 0 && ((String) value).length() > this.length) {
                    value = ((String) value).substring(0, this.length);
                }

                // 2. work with copy from now on!
                returnValue = (String) value;

                // 3. replace special chars
                returnValue = returnValue.replaceAll("\\'", "\\\\\\'");

                // last: put the returnValue inbrackets
                returnValue = "'" + returnValue + "'";
            }

        } else if (valueType.equals(java.lang.Float.class)) {
            returnValue = ((Float) value).toString().replace(",", ".");

        } else if (valueType.equals(java.lang.Integer.class)) {
            returnValue = ((Integer) value).toString();

        } else if (valueType.equals(java.lang.Boolean.class)) {
            returnValue = ((Boolean) value).toString();

        } else if (valueType.equals(java.util.Date.class)) {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
            returnValue = "'" + sdf.format((java.util.Date) value) + "'";

        } else if (valueType.equals(java.sql.Date.class)) {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
            returnValue = "'" + sdf.format((java.sql.Date) value) + "'";

        } else if (valueType.equals(java.sql.Timestamp.class)) {
            returnValue = ((java.sql.Timestamp) value).toString();

        } else if (valueType.equals(java.sql.Time.class)) {
            returnValue = ((java.sql.Time) value).toString();

        } else if (valueType.equals(java.lang.Double.class)) {
            returnValue = ((Double) value).toString().replace(",", ".");

        } else if (valueType.equals(java.math.BigDecimal.class)) {
            returnValue = ((java.math.BigDecimal) value).toString();

        } else if (valueType.equals(Byte.class)) {
            returnValue = ((java.sql.Time) value).toString();

        } else if (valueType.equals(byte[].class)) {
            returnValue = "'" + new String((byte[]) value) + "'";
        }

        return returnValue;

    }

    //<editor-fold defaultstate="collapsed" desc="Generated Getters and Setters">
    public String getDbName() {
        return dbName;
    }

    public void setDbName(String dbName) {
        this.dbName = dbName;
    }

    public GenerationType getGenerationType() {
        return generationType;
    }

    public void setGenerationType(GenerationType generationType) {
        this.generationType = generationType;
    }

    public boolean isInsertable() {
        return insertable;
    }

    public void setInsertable(boolean insertable) {
        this.insertable = insertable;
    }

    public String getJavaName() {
        return javaName;
    }

    public void setJavaName(String javaName) {
        this.javaName = javaName;
    }

    public boolean isKey() {
        return key;
    }

    public void setKey(boolean key) {
        this.key = key;
    }

    public int getLength() {
        return length;
    }

    public void setLength(int length) {
        this.length = length;
    }

    public boolean isLob() {
        return lob;
    }

    public void setLob(boolean lob) {
        this.lob = lob;
    }

    public boolean isNullable() {
        return nullable;
    }

    public void setNullable(boolean nullable) {
        this.nullable = nullable;
    }

    public int getPrecision() {
        return precision;
    }

    public void setPrecision(int precision) {
        this.precision = precision;
    }

    public int getScale() {
        return scale;
    }

    public void setScale(int scale) {
        this.scale = scale;
    }

    public String getSqlDefinition() {
        return sqlDefinition;
    }

    public void setSqlDefinition(String sqlDefinition) {
        this.sqlDefinition = sqlDefinition;
    }

    public boolean isUnique() {
        return unique;
    }

    public void setUnique(boolean unique) {
        this.unique = unique;
    }

    public boolean isUpdatable() {
        return updatable;
    }

    public void setUpdatable(boolean updatable) {
        this.updatable = updatable;
    }

    public Class getValueType() {
        return valueType;
    }

    public void setValueType(Class valueType) {
        this.valueType = valueType;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }
    //</editor-fold>
}
